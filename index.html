<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Moran's I Grid</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #grid-container {
            display: grid;
            grid-template-columns: repeat(10, 45px); /* Adjust size as needed */
            grid-template-rows: repeat(10, 45px);    /* Adjust size as needed */
            border: 1px solid #ccc;
            margin-bottom: 20px;
        }
        .grid-cell {
            border: 1px solid #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* For potential future overlays */
            transition: background-color 0.3s ease; /* Smooth color transition */
        }
        .grid-cell input {
            width: 90%;
            height: 90%;
            text-align: center;
            border: none;
            background-color: transparent; /* Input blends with cell */
            font-size: 1em;
            -moz-appearance: textfield; /* Firefox */
        }
        /* Hide spin buttons on number inputs */
        .grid-cell input::-webkit-outer-spin-button,
        .grid-cell input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        #results, #legend {
            margin-top: 15px;
            text-align: center;
        }
        #legend span {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin: 0 5px;
            border: 1px solid #ccc;
            vertical-align: middle;
        }
        .color-hh { background-color: #FF0000; } /* Red */
        .color-ll { background-color: #0000FF; } /* Blue */
        .color-hl { background-color: #FFA07A; } /* Light Red/Salmon */
        .color-lh { background-color: #ADD8E6; } /* Light Blue */
        .color-ns { background-color: #D3D3D3; } /* Gray */

        button {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
        }
        #controls {
            margin-bottom: 15px;
        }

    </style>
</head>
<body>

    <h1>Interactive Moran's I Grid (10x10)</h1>
    <p>Change cell values to see how Global and Local Moran's I react.</p>

    <div id="grid-container">
        <!-- Grid cells will be generated by JavaScript -->
    </div>

    <div id="controls">
        <button onclick="randomizeGrid()">Randomize Values</button>
        <button onclick="clearGrid()">Clear Grid (Set to 0)</button>
         <button onclick="patternGrid()">Create Pattern</button>
    </div>

    <div id="results">
        Global Moran's I: <span id="global-moran-i">Calculating...</span>
    </div>

    <div id="legend">
        <strong>Legend:</strong>
        <span class="color-hh"></span> High-High (Cluster)
        <span class="color-ll"></span> Low-Low (Cluster)
        <span class="color-hl"></span> High-Low (Outlier)
        <span class="color-lh"></span> Low-High (Outlier)
        <span class="color-ns"></span> Neutral/Mean
    </div>

    <script>
        const ROWS = 10;
        const COLS = 10;
        const N = ROWS * COLS;
        const gridContainer = document.getElementById('grid-container');
        const globalMoranIElement = document.getElementById('global-moran-i');
        let gridValues = new Array(N).fill(0); // Array to store cell values
        let gridCells = []; // Array to store references to cell div elements
        let gridInputs = []; // Array to store references to input elements

        // --- Helper Functions ---
        function getIndex(row, col) {
            return row * COLS + col;
        }

        function getRowCol(index) {
            return { row: Math.floor(index / COLS), col: index % COLS };
        }

        // --- Grid Initialization ---
        function createGrid() {
            gridContainer.innerHTML = ''; // Clear previous grid if any
            gridCells = [];
            gridInputs = [];
            for (let i = 0; i < N; i++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.index = i;

                const input = document.createElement('input');
                input.type = 'number';
                input.value = gridValues[i];
                input.dataset.index = i;
                input.addEventListener('input', handleInputChange); // Use 'input' for real-time updates

                cell.appendChild(input);
                gridContainer.appendChild(cell);
                gridCells.push(cell);
                gridInputs.push(input);
            }
        }

        // --- Spatial Weights Matrix (Rook Contiguity, Row-Standardized) ---
        function getNeighbors(index) {
            const neighbors = [];
            const { row, col } = getRowCol(index);

            // Check Up
            if (row > 0) neighbors.push(getIndex(row - 1, col));
            // Check Down
            if (row < ROWS - 1) neighbors.push(getIndex(row + 1, col));
            // Check Left
            if (col > 0) neighbors.push(getIndex(row, col - 1));
            // Check Right
            if (col < COLS - 1) neighbors.push(getIndex(row, col + 1));

            return neighbors;
        }

        // --- Moran's I Calculations ---
        function calculateMoran() {
            // 1. Calculate Mean (x̄)
            const sum = gridValues.reduce((acc, val) => acc + val, 0);
            const mean = sum / N;

            // Handle case where all values are the same (variance is zero)
            const uniqueValues = new Set(gridValues);
             if (uniqueValues.size <= 1) {
                 globalMoranIElement.textContent = 'N/A (No variance)';
                 updateCellColors(mean, new Array(N).fill(0)); // Color all as neutral
                 return;
             }

            // 2. Calculate Deviations (xi - x̄) and Variance Denominator Term
            const deviations = gridValues.map(val => val - mean);
            const varianceDenom = deviations.reduce((acc, dev) => acc + dev * dev, 0);

             if (varianceDenom === 0) {
                  globalMoranIElement.textContent = 'N/A (Zero variance)';
                  updateCellColors(mean, new Array(N).fill(0)); // Color all as neutral
                  return;
             }

            // 3. Calculate Global Moran's I Numerator and S0
            let globalNumerator = 0;
            let S0 = 0; // Sum of all weights
            const localMoranNumerators = new Array(N).fill(0); // For LISA

            for (let i = 0; i < N; i++) {
                const neighbors = getNeighbors(i);
                const numNeighbors = neighbors.length;
                if (numNeighbors === 0) continue; // Skip cells with no neighbors (unlikely in full grid)

                const wi = 1.0 / numNeighbors; // Row-standardized weight for each neighbor

                for (const j of neighbors) {
                    const wij = wi; // Weight between i and j (row-standardized)
                    globalNumerator += wij * deviations[i] * deviations[j];
                    localMoranNumerators[i] += wij * deviations[j]; // Sum of weighted neighbor deviations (Spatial Lag)
                    S0 += wij; // For row-standardized, S0 should equal N
                }
            }

            // 4. Calculate Global Moran's I
            // Formula: I = (N / S0) * (Σi Σj wij * (xi - x̄) * (xj - x̄)) / (Σi (xi - x̄)²)
            // Since W is row-standardized, S0 = N, so (N / S0) = 1
             const globalMoranI = globalNumerator / varianceDenom;

            // 5. Calculate Local Moran's I (Simplified version)
            // Ii = (zi / (Σk zk^2 / N)) * Σj wij * zj  where zi = xi - x̄
            const variance = varianceDenom / N;
             const localMoranI = deviations.map((dev_i, i) => {
                if (variance === 0) return 0; // Avoid division by zero
                // localMoranNumerators[i] is the spatial lag: Σj wij * (xj - x̄)
                return (dev_i / variance) * localMoranNumerators[i];
            });


            // Display Results
            globalMoranIElement.textContent = globalMoranI.toFixed(4);

            // Update Cell Colors based on LISA classification
            updateCellColors(mean, localMoranNumerators); // Pass mean and spatial lags
        }

        // --- Update Cell Colors (LISA Visualization) ---
        function updateCellColors(mean, spatialLags) {
             gridCells.forEach((cell, i) => {
                const value = gridValues[i];
                const deviation = value - mean;
                const lag = spatialLags[i]; // This is Σj wij * (xj - x̄)

                cell.classList.remove('color-hh', 'color-ll', 'color-hl', 'color-lh', 'color-ns');

                 if (deviation > 0 && lag > 0) {
                    cell.classList.add('color-hh'); // High-High
                } else if (deviation < 0 && lag < 0) {
                    cell.classList.add('color-ll'); // Low-Low
                } else if (deviation > 0 && lag < 0) {
                    cell.classList.add('color-hl'); // High-Low
                } else if (deviation < 0 && lag > 0) {
                    cell.classList.add('color-lh'); // Low-High
                } else {
                     // Includes cases where deviation or lag is zero (or close to it)
                    cell.classList.add('color-ns'); // Neutral / Not Significant (simplified)
                }
            });
        }


        // --- Event Handling ---
        function handleInputChange(event) {
            const index = parseInt(event.target.dataset.index);
            const value = parseFloat(event.target.value) || 0; // Default to 0 if input is invalid/empty

            if (!isNaN(index) && gridValues[index] !== value) {
                 gridValues[index] = value;
                 // Debounce or throttle could be added here for very large grids or complex calcs
                 calculateMoran();
            }
        }

        // --- Control Button Functions ---
        function randomizeGrid() {
             for (let i = 0; i < N; i++) {
                 // Generate random integers between 0 and 99
                 const randomValue = Math.floor(Math.random() * 100);
                 gridValues[i] = randomValue;
                 gridInputs[i].value = randomValue;
             }
             calculateMoran();
        }

         function clearGrid() {
            for (let i = 0; i < N; i++) {
                 gridValues[i] = 0;
                 gridInputs[i].value = 0;
             }
             calculateMoran();
         }

         function patternGrid() {
             for (let i = 0; i < N; i++) {
                 const { row, col } = getRowCol(i);
                 // Example pattern: checkerboard or gradient
                 // Checkerboard:
                 // const value = (row + col) % 2 === 0 ? 10 : 80;
                 // Gradient:
                 const value = row * 10 + col; // Simple gradient
                 gridValues[i] = value;
                 gridInputs[i].value = value;
             }
             calculateMoran();
         }

        // --- Initial Setup ---
        createGrid(); // Create the visual grid
        randomizeGrid(); // Start with random values and calculate initial Moran's I
        // Or:
        // calculateMoran(); // Calculate for initial zeros if you prefer

    </script>

</body>
</html>
